class DoublyLinkedListDemo {

    // Node class
    static class Node {
        int value;
        Node next, prev;
        Node(int value) { this.value = value; }
    }

    Node head, tail;

    // 1️⃣ Insert at beginning → O(1)
    void insertAtBeginning(int value) {
        Node newNode = new Node(value);
        if (head == null) { head = tail = newNode; }
        else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
    }

    // 2️⃣ Insert at end → O(1)
    void insertAtEnd(int value) {
        Node newNode = new Node(value);
        if (tail == null) { head = tail = newNode; }
        else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // 3️⃣ Display forward → O(n)
    void displayForward() {
        System.out.print("Forward: ");
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.value + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    // Display backward → O(n)
    void displayBackward() {
        System.out.print("Backward: ");
        Node temp = tail;
        while (temp != null) {
            System.out.print(temp.value + " ");
            temp = temp.prev;
        }
        System.out.println();
    }

    // 4️⃣ Delete first node → O(1)
    void deleteFirst() {
        if (head == null) return;
        if (head == tail) { head = tail = null; return; }
        head = head.next;
        head.prev = null;
    }

    // Delete last node → O(1)
    void deleteLast() {
        if (tail == null) return;
        if (head == tail) { head = tail = null; return; }
        tail = tail.prev;
        tail.next = null;
    }

    // 5️⃣ Delete node by value → O(n)
    void deleteByValue(int value) {
        Node temp = head;
        while (temp != null && temp.value != value) temp = temp.next;
        if (temp == null) return; // value not found
        if (temp == head) deleteFirst();
        else if (temp == tail) deleteLast();
        else {
            temp.prev.next = temp.next;
            temp.next.prev = temp.prev;
        }
    }

    // 6️⃣ Delete node before a given value → O(n)
    void deleteBeforeValue(int value) {
        Node temp = head;
        while (temp != null && temp.value != value) temp = temp.next;
        if (temp == null || temp.prev == null) return; // no node before
        deleteByValue(temp.prev.value);
    }

    // 7️⃣ Delete node after a given value → O(n)
    void deleteAfterValue(int value) {
        Node temp = head;
        while (temp != null && temp.value != value) temp = temp.next;
        if (temp == null || temp.next == null) return; // no node after
        deleteByValue(temp.next.value);
    }

    // 8️⃣ Find minimum → O(n)
    int findMin() {
        if (head == null) return -1;
        int min = head.value;
        Node temp = head.next;
        while (temp != null) {
            if (temp.value < min) min = temp.value;
            temp = temp.next;
        }
        return min;
    }

    // Find maximum → O(n)
    int findMax() {
        if (head == null) return -1;
        int max = head.value;
        Node temp = head.next;
        while (temp != null) {
            if (temp.value > max) max = temp.value;
            temp = temp.next;
        }
        return max;
    }

    // ======================
    // Main method
    // ======================
    public static void main(String[] args) {
        DoublyLinkedListDemo dll = new DoublyLinkedListDemo();

        // Insert at beginning
        dll.insertAtBeginning(10);
        dll.insertAtBeginning(20);

        // Insert at end
        dll.insertAtEnd(30);
        dll.insertAtEnd(40);
        dll.insertAtEnd(5);
        dll.insertAtEnd(50);

        // Display
        dll.displayForward();
        dll.displayBackward();

        // Delete operations
        dll.deleteFirst();
        dll.deleteLast();
        dll.deleteByValue(20);
        dll.deleteBeforeValue(30);
        dll.deleteAfterValue(20);

        // Display after deletions
        System.out.print("After deletions Forward: ");
        dll.displayForward();
        System.out.println("Minimum value: " + dll.findMin());
        System.out.println("Maximum value: " + dll.findMax());

        // Time complexity summary
        System.out.println("\nTime Complexities:");
        System.out.println("Insert at beginning/end: O(1)");
        System.out.println("Delete first/last: O(1)");
        System.out.println("Delete by value / before / after: O(n)");
        System.out.println("Find min/max: O(n)");
    }
}
QUESTION NO.2:
class QueueImplementation {
    // Part A: Queue using Array

    static class ArrayQueue {
        int[] arr;
        int front, rear, size;

        // Constructor
        ArrayQueue(int capacity) {
            arr = new int[capacity];
            front = 0;
            rear = 0;
            size = 0;
        }

        // Enqueue with dynamic resizing
        void enqueue(int value) {
            if (size == arr.length) {
                System.out.println("Array full. Resizing from " + arr.length + " to " + (arr.length * 2));
                int[] newArr = new int[arr.length * 2];
                for (int i = 0; i < size; i++) newArr[i] = arr[(front + i) % arr.length];
                arr = newArr;
                front = 0;
                rear = size;
            }
            arr[rear] = value;
            rear = (rear + 1) % arr.length;
            size++;
        }

        // Dequeue
        int dequeue() {
            if (size == 0) return -1;
            int value = arr[front];
            front = (front + 1) % arr.length;
            size--;
            return value;
        }

        // Peek
        int peek() {
            return size == 0 ? -1 : arr[front];
        }

        // Display queue
        void display() {
            System.out.print("Queue elements: ");
            for (int i = 0; i < size; i++) System.out.print(arr[(front + i) % arr.length] + " ");
            System.out.println();
        }

        // Find min
        int findMin() {
            int min = Integer.MAX_VALUE;
            for (int i = 0; i < size; i++)
                if (arr[(front + i) % arr.length] < min) min = arr[(front + i) % arr.length];
            return min;
        }

        // Find max
        int findMax() {
            int max = Integer.MIN_VALUE;
            for (int i = 0; i < size; i++)
                if (arr[(front + i) % arr.length] > max) max = arr[(front + i) % arr.length];
            return max;
        }
    }
    
    // Part B: Queue using Linked LisT
    static class LinkedListQueue {
        class Node {
            int value;
            Node next;
            Node(int value) { this.value = value; }
        }

        Node front, rear;

        // Enqueue
        void enqueue(int value) {
            Node newNode = new Node(value);
            if (rear == null) front = rear = newNode;
            else { rear.next = newNode; rear = newNode; }
        }

        // Dequeue
        int dequeue() {
            if (front == null) return -1;
            int val = front.value;
            front = front.next;
            if (front == null) rear = null;
            return val;
        }

        // Peek
        int peek() { return front == null ? -1 : front.value; }

        // Find min
        int findMin() {
            int min = Integer.MAX_VALUE;
            Node temp = front;
            while (temp != null) {
                if (temp.value < min) min = temp.value;
                temp = temp.next;
            }
            return min;
        }

        // Find max
        int findMax() {
            int max = Integer.MIN_VALUE;
            Node temp = front;
            while (temp != null) {
                if (temp.value > max) max = temp.value;
                temp = temp.next;
            }
            return max;
        }

        // Display queue
        void display() {
            System.out.print("Queue elements: ");
            Node temp = front;
            while (temp != null) {
                System.out.print(temp.value + " ");
                temp = temp.next;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {

        System.out.println("=== Array Queue Demo ===");
        ArrayQueue arrayQueue = new ArrayQueue(3); // initial capacity = 3
        arrayQueue.enqueue(10);
        arrayQueue.enqueue(20);
        arrayQueue.enqueue(30);
        arrayQueue.enqueue(40); // triggers resizing
        arrayQueue.display();
        System.out.println("Peek: " + arrayQueue.peek());
        System.out.println("Dequeued: " + arrayQueue.dequeue());
        arrayQueue.display();
        System.out.println("Min: " + arrayQueue.findMin());
        System.out.println("Max: " + arrayQueue.findMax());

        System.out.println("\n=== Linked List Queue Demo ===");
        LinkedListQueue llQueue = new LinkedListQueue();
        llQueue.enqueue(10);
        llQueue.enqueue(20);
        llQueue.enqueue(30);
        llQueue.enqueue(40);
        llQueue.display();
        System.out.println("Peek: " + llQueue.peek());
        System.out.println("Dequeued: " + llQueue.dequeue());
        llQueue.display();
        System.out.println("Min: " + llQueue.findMin());
        System.out.println("Max: " + llQueue.findMax());

        System.out.println("\n=== Comparison ===");
        System.out.println("Array Queue -> Enqueue: O(1) avg, O(n) worst on resize, Dequeue: O(1), Memory: Fixed array (may waste space)");
        System.out.println("Linked List Queue -> Enqueue/Dequeue: O(1), Memory: Flexible, no extra unused space");
    }
}
